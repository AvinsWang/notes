# UNIX环境高级编程(第二版) 
内核: 
系统调用: 内核的接口

口令文件内容(/etc/passwd):  
root:x:0:0:root:/root:/usr/bin/zsh  
登录名:加密口令:用户ID:用户组ID:注释字段:起始目录:shell程序  

shell概述及种类: bash, csh, ksh, tcsh    # p2  
文件属性: 包括文件类型, 文件大新, 文件所有者, 文件权限和文件的最后修改时间  
文件名: 不能只有'/' 或者''   

程序清单1-1: 列出一个目录中的所有文件 ls实现  p4  

<dirent.h>:
opendir	# 返回指向DIR结构体的指针  
readdir	# 读取目录, 返回只想dirent结构体的指针, 没有目录时返回null  
close	# 关闭目录  


程序清单1-2: 将标准输入复制到标准输出 cp实现  p6  
<unistd.h>  
STDIN_FILENO	# 标准输入文件描述符  
STDOUT_FILENO	# 标准输出文件描述符  
read()		# 读取文件返回文件字节数,当到文件尾部,返回0, 错误返回-1  


I/O函数:
- 不用缓冲的I/O: open, read, write, lseek 和 close, 使用文件描述符, 效率受缓冲区大小影响  
- 标准I/O函数: 如printf, 无需担心选择最佳缓冲区  
 
程序清单1-3: 用标准I/O将标准输入复制到标准输出 cp实现  p7  


程序清单1-4: 打印进程ID, getpid()  p8  

程序: 存放在磁盘上的一个可执行文件  
进程: 程序执行的实例  
进程ID: 用于唯一标识每个进程的非负整数  


程序清单1-5: 从标准输入读入命令并执行, 简易的shell程序  p9  ??

fgets		# 从标准输入一次读入一行, 遇到文件结束符^D作为行首字符时, 返回null  

进程控制:  
fork: 创建进程, 如果创建子进程, 向父进程返回pid; 向子进程返回0 ?  
exec: 六种变体  
waitpid: 等待子进程执行完成  ? 

为什么会出现线程: 1.对于某一些问题, 不同部分各使用一个控制线程, 整个问题解决起来变得容易; 2. 并行提高效率  
线程: 一般的,一个进程只有一个控制线程(thread),同一时刻只执行一组机器指令. 一个进程内的所有线程共享同一地址空间,文件描述符,栈以及与进程相关的属性(进程上下文)  
进程ID: 同pid, 但线程id只在所属进程中起作用  
注意: 线程能够访问同一存储区, 各线程访问共享数据时需要避免出现不一致性的问题  

进程和线程的区别:  (知乎)  
进程: CPU性能太强,为了减少CPU等待时间,使用进程提高CPU运算效率. 加载进程1上下文 -> 执行进程1 -> 保存进程1上下文(供下次调用) -> 加载进程2上下文 ...   
线程: 进程粒度太大, 每次执行都要进行上下文切换. 线程是将进程中的任务分成若干部分(按照某种逻辑)如a,b,c, 让CPU依次执行a,b,c; 该过程中只切换线程上下文, 切换时间远小于进程上下文, 提高CPU效率  
疑问: 程序中需要计算10次50!, 如果采用循环为单线程; 采用10个线程,让每个线程计算一次, 该步骤是对进程的任务进行逻辑划分? 逻辑划分是进程自动划分还是手动划分?



